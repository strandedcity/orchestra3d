<html>
<head>
    <script type="text/javascript" src="testmulti3.js"></script>
    <script type="text/javascript">
//        newCurve = Module.cwrap('newCurve','number',['number','number','number','number','number','number','number']);
////        console.log(newCurve());
/////////////////////
//// New versions of the library can be compiled from individual files. For each source file, do this:
////emcc src/construct.c -o construct.bc
////emcc s6drawseq.bc s6move.bc s1602.bc construct.bc s6line.bc s6dist.bc s6err.bc -o testmulti3.js -s EXPORTED_FUNCTIONS="['_s6move','_s6drawseq','_s1602','_newCurve','_s6err','_s6line','_s6dist','_specificNewCurve']" -v -O3
//////////////////////
//
////        // Import function from Emscripten generated file
////        float_multiply_array = Module.cwrap(
////          'float_multiply_array', 'number', ['number', 'number', 'number']
////        );
////
////        // Create example data to test float_multiply_array
////        var data = new Float32Array([1, 2, 3, 4, 5]);
////
////        // Get data byte size, allocate memory on Emscripten heap, and get pointer
////        var nDataBytes = data.length * data.BYTES_PER_ELEMENT;
////        var dataPtr = Module._malloc(nDataBytes);
////
////        // Copy data to Emscripten heap (directly accessed from Module.HEAPU8)
////        var dataHeap = new Uint8Array(Module.HEAPU8.buffer, ptr, nDataBytes);
////        dataHeap.set(new Uint8Array(data.buffer));
////
////        // Call function and get result
////        float_multiply_array(2, dataHeap.byteOffset, data.length);
////        var result = new Float32Array(dataHeap.buffer, dataHeap.byteOffset, data.length);
////
////        // Free memory
////        Module._free(dataHeap.byteOffset);
//
//        // Create example data to test float_multiply_array
//        var coefs = new Float32Array([-1, 1, 0, 0, 1, 0, 1, 1]);
//        var knots = new Float32Array([ 0, 0, 0, 0, 1, 1, 1, 1 ]);
//
//        // Get data byte size, allocate memory on Emscripten heap, and get pointer
//        var ncoefsBytes = coefs.length * coefs.BYTES_PER_ELEMENT;
//        var coefsPtr = Module._malloc(ncoefsBytes);
//        var nknotsBytes = knots.length * knots.BYTES_PER_ELEMENT;
//        var knotsPtr = Module._malloc(nknotsBytes);
//
//
//        Module.writeArrayToMemory([1,0,1],coefsPtr);
//        console.log('reading array from c: ',
//                Module.getValue(coefsPtr,'*'),
//                Module.intArrayFromString(Module.getValue(coefsPtr,'*'))
//        );
//
//        // Copy data to Emscripten heap (directly accessed from Module.HEAPU8)
//        var coefsHeap = new Uint8Array(Module.HEAPU8.buffer, coefsPtr, ncoefsBytes);
//        coefsHeap.set(new Uint8Array(coefs.buffer));
//        var knotsHeap = new Uint8Array(Module.HEAPU8.buffer, knotsPtr, nknotsBytes);
//        knotsHeap.set(new Uint8Array(knots.buffer));
//
//        var resultPtr = Module._malloc(1024*2048);
//
//        Module.stringToUTF32("Hello, world",resultPtr);
//        console.log('reading from c: ',Module.UTF32ToString(resultPtr));
//
//
//
//        var type = 'i8**';
////        Module.setValue(resultPtr,newCurve(4,4,knotsPtr,coefsPtr,1,2,1),type);
//        Module.setValue(resultPtr,newCurve(4,4,knotsPtr,coefsPtr,1,2,1),type);
//
//        console.log('pointer: ',resultPtr, Module.getValue(resultPtr,type));
//

    </script>
</head>
<body>
Loaded.
</body>
</html>